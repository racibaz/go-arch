package module

import (
	"testing"
	"time"

	"github.com/racibaz/go-arch/internal/modules/post/domain"
	"github.com/racibaz/go-arch/internal/modules/post/infrastructure/persistence/gorm/mappers"
	"github.com/racibaz/go-arch/pkg/es"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestSeed_PostCreation(t *testing.T) {
	t.Run("should create valid posts with correct data", func(t *testing.T) {
		// Given - Expected post data from the seeder
		expectedPosts := []*domain.Post{
			{
				Aggregate: es.NewAggregate(
					"2d86263a-eebf-4e7d-867a-0115569d6a3a",
					domain.PostAggregate,
				),
				UserID:      "test-user-id", // Will be generated by uuid.NewID()
				Title:       "test title title title",
				Description: "test description description",
				Content:     "test content content content",
				Status:      domain.PostStatusPublished,
			},
		}

		// When - Create posts using the same logic as seeder
		for _, expectedPost := range expectedPosts {
			post, err := domain.Create(
				expectedPost.ID(),
				expectedPost.UserID,
				expectedPost.Title,
				expectedPost.Description,
				expectedPost.Content,
				expectedPost.Status,
				time.Now(),
				time.Now(),
			)

			// Then
			require.NoError(t, err)
			require.NotNil(t, post)
			assert.Equal(t, expectedPost.Title, post.Title)
			assert.Equal(t, expectedPost.Description, post.Description)
			assert.Equal(t, expectedPost.Content, post.Content)
			assert.Equal(t, expectedPost.Status, post.Status)
			assert.Equal(t, domain.PostAggregate, post.AggregateName())
		}
	})

	t.Run("should create multiple posts successfully", func(t *testing.T) {
		// Given - Test data similar to seeder
		postData := []struct {
			id          string
			userID      string
			title       string
			description string
			content     string
			status      domain.PostStatus
		}{
			{
				id:          "2d86263a-eebf-4e7d-867a-0115569d6a3a",
				userID:      "user-1",
				title:       "test title title title",
				description: "test description description",
				content:     "test content content content",
				status:      domain.PostStatusPublished,
			},
			{
				id:          "test-id-2",
				userID:      "user-2",
				title:       "test title title title",
				description: "test description description",
				content:     "test content content content",
				status:      domain.PostStatusPublished,
			},
		}

		// When & Then
		for _, data := range postData {
			post, err := domain.Create(
				data.id,
				data.userID,
				data.title,
				data.description,
				data.content,
				data.status,
				time.Now(),
				time.Now(),
			)

			require.NoError(t, err)
			require.NotNil(t, post)
			assert.Equal(t, data.id, post.ID())
			assert.Equal(t, data.userID, post.UserID)
			assert.Equal(t, data.title, post.Title)
			assert.Equal(t, data.description, post.Description)
			assert.Equal(t, data.content, post.Content)
			assert.Equal(t, data.status, post.Status)
		}
	})
}

func TestSeed_PostMapping(t *testing.T) {
	t.Run("should map posts to persistence entities correctly", func(t *testing.T) {
		// Given
		post, err := domain.Create(
			"test-id",
			"user-123",
			"Test Title",
			"Test Description",
			"Test Content",
			domain.PostStatusPublished,
			time.Now(),
			time.Now(),
		)
		require.NoError(t, err)
		require.NotNil(t, post)

		// When
		entity, err := mappers.ToPersistence(post)

		// Then
		require.NoError(t, err)
		require.NotNil(t, entity)
		assert.Equal(t, post.ID(), entity.ID)
		assert.Equal(t, post.UserID, entity.UserID)
		assert.Equal(t, post.Title, entity.Title)
		assert.Equal(t, post.Description, entity.Description)
		assert.Equal(t, post.Content, entity.Content)
		assert.Equal(t, int(post.Status), entity.Status)
		assert.NotZero(t, entity.CreatedAt)
		assert.NotZero(t, entity.UpdatedAt)
	})
}

func TestSeed_DataValidation(t *testing.T) {
	t.Run("should validate post data meets domain requirements", func(t *testing.T) {
		// Test cases for domain validation
		testCases := []struct {
			name        string
			title       string
			description string
			content     string
			expectError bool
		}{
			{
				name:        "valid post data",
				title:       "This is a valid title with enough characters",
				description: "This is a valid description with enough characters",
				content:     "This is valid content with enough characters for the post",
				expectError: false,
			},
			{
				name:        "title too short",
				title:       "Hi",
				description: "This is a valid description with enough characters",
				content:     "This is valid content with enough characters for the post",
				expectError: true,
			},
			{
				name:        "description too short",
				title:       "This is a valid title with enough characters",
				description: "Short",
				content:     "This is valid content with enough characters for the post",
				expectError: true,
			},
			{
				name:        "content too short",
				title:       "This is a valid title with enough characters",
				description: "This is a valid description with enough characters",
				content:     "Short",
				expectError: true,
			},
		}

		for _, tc := range testCases {
			t.Run(tc.name, func(t *testing.T) {
				_, err := domain.Create(
					"test-id",
					"user-123",
					tc.title,
					tc.description,
					tc.content,
					domain.PostStatusDraft,
					time.Now(),
					time.Now(),
				)

				if tc.expectError {
					assert.Error(t, err)
				} else {
					assert.NoError(t, err)
				}
			})
		}
	})
}

func TestSeed_PostAggregate(t *testing.T) {
	t.Run("should create posts with correct aggregate type", func(t *testing.T) {
		// Given
		post, err := domain.Create(
			"test-id",
			"user-123",
			"Valid Title With Enough Characters",
			"Valid Description With Enough Characters",
			"Valid Content With Enough Characters For Testing",
			domain.PostStatusPublished,
			time.Now(),
			time.Now(),
		)

		// Then
		require.NoError(t, err)
		require.NotNil(t, post)
		assert.Equal(t, domain.PostAggregate, post.AggregateName())
		assert.Equal(t, "test-id", post.ID())
	})
}

func TestSeed_PostStatuses(t *testing.T) {
	t.Run("should create posts with different statuses", func(t *testing.T) {
		// Test all post statuses
		statuses := []domain.PostStatus{
			domain.PostStatusDraft,
			domain.PostStatusPublished,
			domain.PostStatusArchived,
		}

		for _, status := range statuses {
			t.Run(status.String(), func(t *testing.T) {
				post, err := domain.Create(
					"test-id-"+status.String(),
					"user-123",
					"Valid Title With Enough Characters",
					"Valid Description With Enough Characters",
					"Valid Content With Enough Characters For Testing",
					status,
					time.Now(),
					time.Now(),
				)

				require.NoError(t, err)
				require.NotNil(t, post)
				assert.Equal(t, status, post.Status)
			})
		}
	})
}

func TestSeed_DomainValidationErrors(t *testing.T) {
	t.Run("should handle domain creation errors", func(t *testing.T) {
		// Test cases that should cause domain validation errors
		invalidPosts := []struct {
			name        string
			id          string
			userID      string
			title       string
			description string
			content     string
			status      domain.PostStatus
		}{
			{
				name:        "empty title",
				id:          "test-id-1",
				userID:      "user-123",
				title:       "",
				description: "Valid description with enough characters",
				content:     "Valid content with enough characters for testing",
				status:      domain.PostStatusDraft,
			},
			{
				name:        "title too short",
				id:          "test-id-2",
				userID:      "user-123",
				title:       "Hi",
				description: "Valid description with enough characters",
				content:     "Valid content with enough characters for testing",
				status:      domain.PostStatusDraft,
			},
			{
				name:        "description too short",
				id:          "test-id-3",
				userID:      "user-123",
				title:       "Valid Title With Enough Characters",
				description: "Short",
				content:     "Valid content with enough characters for testing",
				status:      domain.PostStatusDraft,
			},
			{
				name:        "content too short",
				id:          "test-id-4",
				userID:      "user-123",
				title:       "Valid Title With Enough Characters",
				description: "Valid description with enough characters",
				content:     "Short",
				status:      domain.PostStatusDraft,
			},
		}

		for _, tc := range invalidPosts {
			t.Run(tc.name, func(t *testing.T) {
				// Attempt to create a post with invalid data (similar to what seeder does)
				_, err := domain.Create(
					tc.id,
					tc.userID,
					tc.title,
					tc.description,
					tc.content,
					tc.status,
					time.Now(),
					time.Now(),
				)

				// Should return an error for invalid data
				assert.Error(t, err, "Domain creation should fail for invalid data: %s", tc.name)
			})
		}
	})
}

func TestSeed_MapperErrors(t *testing.T) {
	t.Run("should handle nil post mapping errors", func(t *testing.T) {
		// When
		entity, err := mappers.ToPersistence(nil)

		// Then
		assert.Error(t, err)
		assert.Nil(t, entity)
		assert.Contains(t, err.Error(), "post is nil")
	})

	t.Run("should handle valid post mapping", func(t *testing.T) {
		// Given
		post, err := domain.Create(
			"test-id",
			"user-123",
			"Valid Title With Enough Characters",
			"Valid Description With Enough Characters",
			"Valid Content With Enough Characters For Testing",
			domain.PostStatusPublished,
			time.Now(),
			time.Now(),
		)
		require.NoError(t, err)
		require.NotNil(t, post)

		// When
		entity, err := mappers.ToPersistence(post)

		// Then
		assert.NoError(t, err)
		assert.NotNil(t, entity)
		assert.Equal(t, post.ID(), entity.ID)
		assert.Equal(t, post.UserID, entity.UserID)
		assert.Equal(t, post.Title, entity.Title)
		assert.Equal(t, int(post.Status), entity.Status)
	})
}

func TestSeed_ErrorScenarios(t *testing.T) {
	t.Run("should validate seeder data matches domain requirements", func(t *testing.T) {
		// Test the actual data used in the seeder to ensure it meets domain requirements
		seederData := []struct {
			title       string
			description string
			content     string
		}{
			{
				title:       "test title title title",
				description: "test description description",
				content:     "test content content content",
			},
		}

		for _, data := range seederData {
			t.Run("seeder data validation", func(t *testing.T) {
				// This should succeed since the seeder data should be valid
				post, err := domain.Create(
					"test-id",
					"user-123",
					data.title,
					data.description,
					data.content,
					domain.PostStatusPublished,
					time.Now(),
					time.Now(),
				)

				// The seeder data should be valid
				assert.NoError(t, err, "Seeder data should be valid")
				assert.NotNil(t, post, "Post should be created successfully")
			})
		}
	})

	t.Run("should handle aggregate creation correctly", func(t *testing.T) {
		// Test that the aggregate is created properly (similar to seeder logic)
		aggregate := es.NewAggregate("test-aggregate-id", domain.PostAggregate)

		// Verify aggregate properties
		assert.Equal(t, "test-aggregate-id", aggregate.ID())
		assert.Equal(t, domain.PostAggregate, aggregate.AggregateName())
	})
}

func TestSeed_ComprehensivePostCreation(t *testing.T) {
	t.Run("should create posts with all required fields", func(t *testing.T) {
		// Test comprehensive post creation similar to seeder
		postData := []struct {
			name        string
			id          string
			userID      string
			title       string
			description string
			content     string
			status      domain.PostStatus
		}{
			{
				name:        "first post with fixed ID",
				id:          "2d86263a-eebf-4e7d-867a-0115569d6a3a",
				userID:      "user-123",
				title:       "test title title title",
				description: "test description description",
				content:     "test content content content",
				status:      domain.PostStatusPublished,
			},
			{
				name:        "second post with generated ID",
				id:          "generated-id-2",
				userID:      "user-456",
				title:       "test title title title",
				description: "test description description",
				content:     "test content content content",
				status:      domain.PostStatusPublished,
			},
		}

		for _, tc := range postData {
			t.Run(tc.name, func(t *testing.T) {
				// Create aggregate (like seeder does)
				aggregate := es.NewAggregate(tc.id, domain.PostAggregate)

				// Create post with seeder-like data
				post := &domain.Post{
					Aggregate:   aggregate,
					UserID:      tc.userID,
					Title:       tc.title,
					Description: tc.description,
					Content:     tc.content,
					Status:      tc.status,
					CreatedAt:   time.Now(),
					UpdatedAt:   time.Now(),
				}

				// Validate using domain Create function (like seeder does)
				createdPost, err := domain.Create(
					post.ID(),
					post.UserID,
					post.Title,
					post.Description,
					post.Content,
					post.Status,
					post.CreatedAt,
					post.UpdatedAt,
				)

				assert.NoError(t, err, "Post creation should succeed")
				assert.NotNil(t, createdPost, "Created post should not be nil")
				assert.Equal(t, tc.id, createdPost.ID())
				assert.Equal(t, tc.userID, createdPost.UserID)
				assert.Equal(t, tc.title, createdPost.Title)
				assert.Equal(t, tc.description, createdPost.Description)
				assert.Equal(t, tc.content, createdPost.Content)
				assert.Equal(t, tc.status, createdPost.Status)
			})
		}
	})
}
